// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.uicd.backend.core.db;

import com.google.api.client.util.Base64;
import com.google.common.collect.ImmutableList;
import com.google.uicd.backend.core.constants.ActionType;
import com.google.uicd.backend.core.exceptions.UicdActionException;
import com.google.uicd.backend.core.uicdactions.BaseAction;
import com.google.uicd.backend.core.uicdactions.CompoundAction;
import com.google.uicd.backend.core.uicdactions.ImageDiffValidationAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.LogManager;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * ActionStorageManager is a helper class the manage high level API for action storage. In current
 * design, since we have compound actions, it is like a tree structure, we need store the "tree" in
 * the database in a flatten way. Using this class we can easily convert back and forward.
 */
public abstract class ActionStorageManager {

  /** Internal cache to reduce the storage layer(db/filesystem) access. */
  protected final Map<String, BaseAction> cachedMap = new HashMap<>();

  protected Logger logger = LogManager.getLogManager().getLogger("uicd");

  /* clear the internal cache */
  public void clearCache() {
    cachedMap.clear();
  }

  public abstract List<BaseAction> getBaseActionsFromStorage(List<String> actionIdList)
      throws UicdActionException;
  /**
   * Gets and deserialize action by actionID, this method need to be synchronized, otherwise cache
   * could be in a incomplete state, and other thread might get the incorrect result.
   *
   * @param uuidStr action id in string format
   */
  public synchronized BaseAction getActionByUUID(String uuidStr) throws UicdActionException {
    if (cachedMap.containsKey(uuidStr)) {
      return cachedMap.get(uuidStr);
    }
    // BFS to fetch children compound actions, while doing the bfs, will ignore the real children
    // action first, will populate the field once we have everything ready in the memory.
    List<String> parentLayerActionIds = Arrays.asList(uuidStr);
    while (!parentLayerActionIds.isEmpty()) {
      List<BaseAction> currentActionList = getBaseActionsFromStorage(parentLayerActionIds);
      List<String> nextLayerActionIds = new ArrayList<>();
      for (BaseAction curAction : currentActionList) {
        if (curAction.getActionType() == ActionType.COMPOUND_ACTION) {
          CompoundAction compoundAction = (CompoundAction) curAction;
          for (BaseAction childAction : compoundAction.childrenActions) {
            cachedMap.putIfAbsent(childAction.getActionId().toString(), childAction);
          }
          nextLayerActionIds.addAll(
              compoundAction.childrenIdList.stream()
                  .filter(actionId -> !cachedMap.containsKey(actionId))
                  .collect(Collectors.toList()));
        }
        loadRefImgIfImgDiffValAction(curAction);
        cachedMap.putIfAbsent(curAction.getActionId().toString(), curAction);
      }
      parentLayerActionIds = nextLayerActionIds;
    }
    expendAllActionsReference();
    return cachedMap.get(uuidStr);
  }

  /**
   * Deserializes the action from json string format, the string should be generated by the export
   * feature(different than what stored in database)
   *
   * @param actionDetails action in json string formatter
   */
  public BaseAction loadMapFromString(String actionDetails) throws UicdActionException {
    BaseAction action = BaseAction.fromJson(actionDetails);
    if (action == null) {
      throw new UicdActionException("Failed to load Action.");
    }
    loadActionToCachedMap(action);
    return action;
  }

  /**
   * Updates the action base on the json string provided by frontend.
   *
   * @param jsonStr action in Json format
   */
  public BaseAction updateActionMetadata(String jsonStr) {
    BaseAction baseActionFromFrontend = BaseAction.fromJson(jsonStr);
    BaseAction action = cachedMap.get(baseActionFromFrontend.getActionId().toString());
    action.updateAction(baseActionFromFrontend);
    saveAction(action);
    return action;
  }

  /** Serializes and saves action into (db/filesystem) */
  public boolean saveAction(BaseAction action) {
    try {
      cachedMap.putIfAbsent(action.getActionId().toString(), action);
      return saveActions(ImmutableList.of(action));
    } catch (UicdActionException e) {
      logger.severe("Failed to add action");
    }
    return false;
  }

  /** Serializes and saves action list into (db/filesystem) */
  public abstract boolean saveActions(List<BaseAction> actions) throws UicdActionException;

  protected void expendAllActionsReference() {
    // Updates cacheMap, for each compound action in the cachedMap, once we have all the action in
    // cachedMap we need construct the real object reference.
    for (BaseAction action : cachedMap.values()) {
      if (action.getActionType() == ActionType.COMPOUND_ACTION) {
        CompoundAction compoundAction = (CompoundAction) action;
        if (compoundAction.childrenIdList.size() != compoundAction.childrenActions.size()) {
          compoundAction.childrenActions =
              compoundAction.childrenIdList.stream()
                  .map(actionId -> cachedMap.get(actionId))
                  .collect(Collectors.toList());
        }
      }
    }
  }

  protected static BaseAction loadRefImgIfImgDiffValAction(BaseAction baseAction) {
    if (baseAction instanceof ImageDiffValidationAction) {
      ImageDiffValidationAction imgValAction = (ImageDiffValidationAction) baseAction;
      imgValAction.setRefImage(
          ImageStorageManager.getInstance().getImage(imgValAction.getRefImageUuid()));
      return imgValAction;
    }
    return baseAction;
  }

  private void loadActionToCachedMap(BaseAction action) {
    if (cachedMap.putIfAbsent(action.getActionId().toString(), action) == null) {
      if (action instanceof CompoundAction) {
        CompoundAction compoundAction = (CompoundAction) action;
        for (BaseAction child : compoundAction.childrenActions) {
          loadActionToCachedMap(child);
        }
      }
    }
  }

  public Map<String, String> getUuidToBase64RefImgs(String uuidStr) throws UicdActionException {
    Map<String, String> uuidToBase64RefImgs = new HashMap<>();
    BaseAction action = getActionByUUID(uuidStr);
    if (action instanceof CompoundAction) {
      CompoundAction cmpAction = (CompoundAction) action;
      for (BaseAction childAction : cmpAction.childrenActions) {
        uuidToBase64RefImgs.putAll(getUuidToBase64RefImgs(childAction.getActionId().toString()));
      }
    } else if (action instanceof ImageDiffValidationAction) {
      ImageDiffValidationAction imgValAction = (ImageDiffValidationAction) action;
      if (imgValAction.getRefImage() != null) {
        uuidToBase64RefImgs.put(
            imgValAction.getRefImageUuid(), Base64.encodeBase64String(imgValAction.getRefImage()));
      } else {
        uuidToBase64RefImgs.put(
            imgValAction.getRefImageUuid(),
            Base64.encodeBase64String(
                ImageStorageManager.getInstance().getImage(imgValAction.getRefImageUuid())));
      }
    }
    return uuidToBase64RefImgs;
  }
}
